name: CI

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  build-test:
    name: Build and test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
    steps:
      - uses: actions/checkout@v4

      - name: Restore uv/pip caches
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/uv
            ~/.cache/pip
          key: ${{ runner.os }}-uvpip-${{ hashFiles('uv.lock', 'pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-uvpip-

      # Install uv and Python 3.12 (aligns with hg_cpp approach)
      - uses: astral-sh/setup-uv@v4
        with:
          python-version: '3.12'

      # Ensure Conan is available for builds/tools
      - name: Install Conan via uv tool
        run: uv tool install conan

      # Build the wheel with nanobind stable ABI enabled
      - name: Build wheel (NB stable ABI, Windows MSVC)
        if: runner.os == 'Windows'
        env:
          CMAKE_ARGS: -DNB_USE_STABLE_ABI=ON
          CMAKE_GENERATOR: "Visual Studio 17 2022"
          CMAKE_GENERATOR_PLATFORM: x64
        run: uv build -v

      - name: Build wheel (NB stable ABI, macOS Ninja)
        if: runner.os == 'macOS'
        env:
          CMAKE_ARGS: -DNB_USE_STABLE_ABI=ON
          CMAKE_GENERATOR: Ninja
        run: uv build -v

      - name: Install GCC 13 (Linux only)
        if: runner.os == 'Linux'
        run: |
          set -eo pipefail
          echo "Adding Debian testing repository for GCC 13..."
          echo "deb http://deb.debian.org/debian testing main" | sudo tee /etc/apt/sources.list.d/testing.list
          sudo apt-get update
          sudo apt-get install -y g++-13 gcc-13
          sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 100
          sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 100
          gcc --version
          g++ --version

      - name: Build wheel (NB stable ABI + ASan, Linux Ninja)
        if: runner.os == 'Linux'
        env:
          CMAKE_GENERATOR: Ninja
          # scikit-build-core reads this environment variable for extra CMake args
          SKBUILD_CMAKE_ARGS: "-DNB_USE_STABLE_ABI=ON;-DHGRAPH_ENABLE_ASAN=ON;-DHGRAPH_ENABLE_UBSAN=OFF;-DCMAKE_BUILD_TYPE=RelWithDebInfo"
        run: |
          set -eo pipefail
          echo "Building with ASan enabled..."
          echo "SKBUILD_CMAKE_ARGS=$SKBUILD_CMAKE_ARGS"
          uv build -v 2>&1 | tee build.log
          # Verify ASan is in the build
          echo "=== Checking for ASan in build output ==="
          grep -i "sanitizer\|asan\|fsanitize" build.log || echo "No sanitizer mentions found in build log"
          # Show what was built
          ls -la dist/
          # Verify ASan symbols in the wheel
          echo "=== Verifying ASan symbols in wheel ==="
          wheel=$(ls dist/*.whl | head -1)
          unzip -p "$wheel" "hgraph/_hgraph*.so" > /tmp/ext_from_wheel.so
          nm -D /tmp/ext_from_wheel.so | grep -i asan | head -10 || echo "WARNING: No ASan symbols found in wheel!"

      - name: Prepare test environment (all groups and extras)
        run: |
          uv venv
          uv sync --all-extras --all-groups

      - name: List dist artifacts (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path dist) { Get-ChildItem dist | Format-Table Name,Length,LastWriteTime -AutoSize } else { Write-Host "dist directory not found" }
      - name: List dist artifacts (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          ls -la dist || true

      - name: Upload built wheels (all OS)
        uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ runner.os }}
          path: dist/**
          if-no-files-found: ignore
          retention-days: 7

      # Repair Linux wheel to manylinux using auditwheel (do not publish unrepaired wheels)
      - name: Repair Linux wheel with auditwheel (Linux only)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          ls -la dist || true
          wheel=$(ls dist/*.whl | head -n1 || true)
          if [ -z "${wheel}" ]; then
            echo "No wheel found in dist/"
            exit 1
          fi
          uv pip install --upgrade pip
          uv pip install auditwheel
          # Show before/after info for debugging
          uv run python -m auditwheel show "${wheel}" || true
          mkdir -p wheelhouse
          uv run python -m auditwheel repair -w wheelhouse "${wheel}"
          ls -la wheelhouse || true

      - name: Upload repaired Linux wheels (manylinux)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: wheels-linux-manylinux
          path: wheelhouse/**
          if-no-files-found: error
          retention-days: 7

      - name: Install built wheel into env (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $wheel = (Get-ChildItem dist/*.whl | Select-Object -First 1).FullName
          if (-not $wheel) { Write-Error "No wheel found in dist/"; Get-ChildItem dist -Recurse; exit 1 }
          uv pip install --upgrade pip
          uv pip install "$wheel"

      - name: Install built wheel into env (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          wheel=$(ls dist/*.whl | head -n1 || true)
          if [ -z "${wheel}" ]; then
            echo "No wheel found in dist/"
            ls -la dist || true
            exit 1
          fi
          uv pip install --upgrade pip
          # Force reinstall to override any version installed by uv sync
          uv pip install --force-reinstall --no-deps "${wheel}"
          echo "Installed wheel: ${wheel}"

      - name: Install built wheel into env (Linux with ASan)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          wheel=$(ls dist/*.whl | head -n1 || true)
          if [ -z "${wheel}" ]; then
            echo "No wheel found in dist/"
            ls -la dist || true
            exit 1
          fi
          uv pip install --upgrade pip
          # Uninstall editable install from uv sync
          uv pip uninstall hgraph || true
          # Install the ASan-enabled wheel
          uv pip install --no-deps "${wheel}"
          echo "Installed wheel: ${wheel}"

          # CRITICAL: Manually copy the ASan-enabled extension from the wheel
          # This prevents uv from rebuilding it without ASan when we run tests
          echo "=== Copying ASan-enabled extension from wheel ==="
          unzip -p "$wheel" "hgraph/_hgraph*.so" > /tmp/ext_asan.so
          ext_install_path=$(.venv/bin/python -c "import sysconfig; print(sysconfig.get_path('purelib'))")/hgraph/_hgraph.cpython-312-x86_64-linux-gnu.so
          echo "Extension install path: $ext_install_path"
          cp /tmp/ext_asan.so "$ext_install_path"
          echo "Verifying ASan symbols in installed extension..."
          nm -D "$ext_install_path" | grep -i asan | head -5 || echo "WARNING: No ASan symbols in installed extension!"
          ls -lh "$ext_install_path"

      - name: Run smoke tests (macOS/Windows) [Python runtime]
        if: runner.os != 'Linux'
        shell: bash
        env:
          HGRAPH_USE_CPP: 'false'
        run: |
          set -euo pipefail
          echo "HGRAPH_USE_CPP=$HGRAPH_USE_CPP"
          uv run pytest -q -m smoke

      - name: Run smoke tests (macOS/Windows) [C++ runtime]
        if: runner.os != 'Linux'
        shell: bash
        env:
          HGRAPH_USE_CPP: 'true'
        run: |
          set -euo pipefail
          echo "HGRAPH_USE_CPP=$HGRAPH_USE_CPP"
          uv run pytest -q -m smoke

      - name: Run tests (Linux only) [Python runtime]
        if: runner.os == 'Linux'
        env:
          HGRAPH_USE_CPP: 'false'
          PYTHONFAULTHANDLER: '1'
        run: |
          set -euo pipefail
          echo "HGRAPH_USE_CPP=$HGRAPH_USE_CPP"
          ulimit -c unlimited || true
          echo "Discovering extension paths..."
          .venv/bin/python -c "import importlib.util as u, sys; m=u.find_spec('_hgraph'); print('_hgraph:', getattr(m,'origin',None) or 'not installed')"
          .venv/bin/python -c "import hgraph; print('hgraph:', hgraph.__file__)"
          .venv/bin/pytest -ra -q --cov=hgraph --cov-report=xml

      - name: Verify ASan in installed extension (Linux only)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -eo pipefail
          echo "=== Checking if ASan is linked into the extension ==="
          echo "Which hgraph is installed:"
          uv pip show hgraph || echo "hgraph not found via pip show"
          ext_path=$(.venv/bin/python -c "import hgraph._hgraph as m; print(m.__file__)" 2>/dev/null || echo "")
          if [ -n "$ext_path" ] && [ -f "$ext_path" ]; then
            echo "Extension path: $ext_path"
            echo "Extension file size: $(ls -lh "$ext_path")"
            echo ""
            echo "Checking for ASan symbols..."
            nm -D "$ext_path" 2>/dev/null | grep -i asan | head -20 || echo "No ASan symbols found via nm"
            echo ""
            echo "Checking md5sum to ensure it matches wheel..."
            md5sum "$ext_path" /tmp/ext_asan.so || true
          else
            echo "ERROR: Could not find extension at: $ext_path"
            echo "Trying to list hgraph package contents:"
            .venv/bin/python -c "import hgraph; import os; print(os.listdir(os.path.dirname(hgraph.__file__)))"
            exit 1
          fi

      - name: Run tests (Linux only) [C++ runtime with ASan]
        if: runner.os == 'Linux'
        continue-on-error: true
        env:
          HGRAPH_USE_CPP: 'true'
          PYTHONFAULTHANDLER: '1'
          # Note: print_stacktrace is not a valid option, removed
          ASAN_OPTIONS: detect_leaks=0:halt_on_error=0:abort_on_error=0:log_path=asan.log
          ASAN_SYMBOLIZER_PATH: /usr/bin/llvm-symbolizer
          PYTHONMALLOC: malloc
          # Preload ASan runtime since Python isn't compiled with ASan
          LD_PRELOAD: /usr/lib/gcc/x86_64-linux-gnu/13/libasan.so
        run: |
          set -eo pipefail
          echo "HGRAPH_USE_CPP=$HGRAPH_USE_CPP"
          echo "ASAN_OPTIONS=$ASAN_OPTIONS"
          echo "LD_PRELOAD=$LD_PRELOAD"
          # Check if llvm-symbolizer is available
          which llvm-symbolizer || sudo apt-get install -y llvm || true
          # Verify ASan library exists
          if [ ! -f "$LD_PRELOAD" ]; then
            echo "ERROR: ASan library not found at $LD_PRELOAD"
            find /usr/lib -name "libasan.so*" 2>/dev/null || true
            exit 1
          fi
          ulimit -c unlimited || true
          echo "Discovering extension paths..."
          .venv/bin/python -c "import importlib.util as u, sys; m=u.find_spec('_hgraph'); print('_hgraph:', getattr(m,'origin',None) or 'not installed')"
          .venv/bin/python -c "import hgraph; print('hgraph:', hgraph.__file__)"
          # Run a simple import test first
          echo "Testing basic import with ASan..."
          .venv/bin/python -c "import hgraph; print('Import OK')" || echo "Import failed with code $?"
          # Run pytest with ASan enabled
          echo "Running pytest with ASan..."
          .venv/bin/pytest -ra -q --cov=hgraph --cov-report=xml 2>&1 || echo "Tests exited with code $?"
          # Show ASan log if it exists
          echo "=== ASan log output ==="
          cat asan.log* 2>/dev/null || echo "No ASan log files found"

      - name: Upload ASan logs (Linux only)
        if: always() && runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: asan-logs
          path: asan.log*
          if-no-files-found: ignore
          retention-days: 7

      - name: Collect crash artifacts (Linux only)
        if: failure() && runner.os == 'Linux'
        shell: bash
        run: |
          set -eo pipefail
          echo "Collecting core dumps and backtraces..."
          sudo apt-get update >/dev/null 2>&1 || true
          sudo apt-get install -y gdb >/dev/null 2>&1 || true
          shopt -s nullglob || true
          CORES=(core core.* /var/crash/*.crash /var/crash/*.core /home/runner/work/*/*/core*)
          echo "Found ${#CORES[@]} core candidates"
          for c in "${CORES[@]}"; do
            echo "==> Core file: $c"
            file "$c" || true
            which python || true
            gdb -q -n -batch -ex "set pagination off" -ex "thread apply all bt full" -ex "quit" "$(which python)" "$c" || true
          done

      - name: Upload core dumps (Linux only)
        if: failure() && runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: linux-core-dumps
          path: |
            core*
            /var/crash/*.crash
            /var/crash/*.core
            /home/runner/work/*/*/core*
          if-no-files-found: ignore
          retention-days: 7

